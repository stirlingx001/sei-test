// File automatically generated by protoc-gen-sol unspecified version
// SPDX-License-Identifier: Apache-2.0
pragma solidity >=0.6.0 <8.0.0;
pragma experimental ABIEncoderV2;

import "@lazyledger/protobuf3-solidity-lib/contracts/ProtobufLib.sol";

struct MsgEVMTransactionResponse {
    uint64 gas_used;
    string vm_error;
    bytes return_data;
    string hash;
    Log[] logs;
}

library MsgEVMTransactionResponseCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, MsgEVMTransactionResponse memory) {
        // Message instance
        MsgEVMTransactionResponse memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 5) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 4) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 5) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, MsgEVMTransactionResponse memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 4) {
            bool success;
            (success, pos) = decode_4(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 5) {
            bool success;
            (success, pos) = decode_5(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // MsgEVMTransactionResponse.gas_used
    function decode_1(uint64 pos, bytes memory buf, MsgEVMTransactionResponse memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 v;
        (success, pos, v) = ProtobufLib.decode_uint64(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.gas_used = v;

        return (true, pos);
    }

    // MsgEVMTransactionResponse.vm_error
    function decode_2(uint64 pos, bytes memory buf, MsgEVMTransactionResponse memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.vm_error = v;

        return (true, pos);
    }

    // MsgEVMTransactionResponse.return_data
    function decode_3(uint64 pos, bytes memory buf, MsgEVMTransactionResponse memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.return_data = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.return_data[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // MsgEVMTransactionResponse.hash
    function decode_4(uint64 pos, bytes memory buf, MsgEVMTransactionResponse memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.hash = v;

        return (true, pos);
    }

    // MsgEVMTransactionResponse.logs
    function decode_5(uint64 pos, bytes memory buf, MsgEVMTransactionResponse memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 initial_pos = pos;

        // Do one pass to count the number of elements
        uint64 cnt = 0;
        while (pos < buf.length) {
            uint64 len;
            (success, pos, len) = ProtobufLib.decode_embedded_message(pos, buf);
            if (!success) {
                return (false, pos);
            }

            // Sanity checks
            if (pos + len < pos) {
                return (false, pos);
            }

            pos += len;
            cnt += 1;

            if (pos >= buf.length) {
                break;
            }

            // Decode next key
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos);
            }

            // Check if the field number is different
            if (field_number != 5) {
                break;
            }
        }

        // Allocated memory
        instance.logs = new Log[](cnt);

        // Now actually parse the elements
        pos = initial_pos;
        for (uint64 i = 0; i < cnt; i++) {
            uint64 len;
            (success, pos, len) = ProtobufLib.decode_embedded_message(pos, buf);
            if (!success) {
                return (false, pos);
            }

            initial_pos = pos;

            Log memory nestedInstance;
            (success, pos, nestedInstance) = LogCodec.decode(pos, buf, len);
            if (!success) {
                return (false, pos);
            }

            instance.logs[i] = nestedInstance;

            // Skip over next key, reuse len
            if (i < cnt - 1) {
                (success, pos, len) = ProtobufLib.decode_uint64(pos, buf);
                if (!success) {
                    return (false, pos);
                }
            }
        }

        return (true, pos);
    }

}

struct Log {
    string address;
    Topic[] topics;
    bytes data;
    uint32 index;
    bool synthetic;
}

library LogCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, Log memory) {
        // Message instance
        Log memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 5) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 2) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 3) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        if (field_number == 4) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        if (field_number == 5) {
            return wire_type == ProtobufLib.WireType.Varint;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, Log memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 2) {
            bool success;
            (success, pos) = decode_2(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 3) {
            bool success;
            (success, pos) = decode_3(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 4) {
            bool success;
            (success, pos) = decode_4(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        if (field_number == 5) {
            bool success;
            (success, pos) = decode_5(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // Log.address
    function decode_1(uint64 pos, bytes memory buf, Log memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.address = v;

        return (true, pos);
    }

    // Log.topics
    function decode_2(uint64 pos, bytes memory buf, Log memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 initial_pos = pos;

        // Do one pass to count the number of elements
        uint64 cnt = 0;
        while (pos < buf.length) {
            uint64 len;
            (success, pos, len) = ProtobufLib.decode_embedded_message(pos, buf);
            if (!success) {
                return (false, pos);
            }

            // Sanity checks
            if (pos + len < pos) {
                return (false, pos);
            }

            pos += len;
            cnt += 1;

            if (pos >= buf.length) {
                break;
            }

            // Decode next key
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos);
            }

            // Check if the field number is different
            if (field_number != 2) {
                break;
            }
        }

        // Allocated memory
        instance.topics = new Topic[](cnt);

        // Now actually parse the elements
        pos = initial_pos;
        for (uint64 i = 0; i < cnt; i++) {
            uint64 len;
            (success, pos, len) = ProtobufLib.decode_embedded_message(pos, buf);
            if (!success) {
                return (false, pos);
            }

            initial_pos = pos;

            Topic memory nestedInstance;
            (success, pos, nestedInstance) = TopicCodec.decode(pos, buf, len);
            if (!success) {
                return (false, pos);
            }

            instance.topics[i] = nestedInstance;

            // Skip over next key, reuse len
            if (i < cnt - 1) {
                (success, pos, len) = ProtobufLib.decode_uint64(pos, buf);
                if (!success) {
                    return (false, pos);
                }
            }
        }

        return (true, pos);
    }

    // Log.data
    function decode_3(uint64 pos, bytes memory buf, Log memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint64 len;
        (success, pos, len) = ProtobufLib.decode_bytes(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (len == 0) {
            return (false, pos);
        }

        instance.data = new bytes(len);
        for (uint64 i = 0; i < len; i++) {
            instance.data[i] = buf[pos + i];
        }

        pos = pos + len;

        return (true, pos);
    }

    // Log.index
    function decode_4(uint64 pos, bytes memory buf, Log memory instance) internal pure returns (bool, uint64) {
        bool success;

        uint32 v;
        (success, pos, v) = ProtobufLib.decode_uint32(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == 0) {
            return (false, pos);
        }

        instance.index = v;

        return (true, pos);
    }

    // Log.synthetic
    function decode_5(uint64 pos, bytes memory buf, Log memory instance) internal pure returns (bool, uint64) {
        bool success;

        bool v;
        (success, pos, v) = ProtobufLib.decode_bool(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (v == false) {
            return (false, pos);
        }

        instance.synthetic = v;

        return (true, pos);
    }

}

struct Topic {
    string topic;
}

library TopicCodec {
    function decode(uint64 initial_pos, bytes memory buf, uint64 len) internal pure returns (bool, uint64, Topic memory) {
        // Message instance
        Topic memory instance;
        // Previous field number
        uint64 previous_field_number = 0;
        // Current position in the buffer
        uint64 pos = initial_pos;

        // Sanity checks
        if (pos + len < pos) {
            return (false, pos, instance);
        }

        while (pos - initial_pos < len) {
            // Decode the key (field number and wire type)
            bool success;
            uint64 field_number;
            ProtobufLib.WireType wire_type;
            (success, pos, field_number, wire_type) = ProtobufLib.decode_key(pos, buf);
            if (!success) {
                return (false, pos, instance);
            }

            // Check that the field number is within bounds
            if (field_number > 1) {
                return (false, pos, instance);
            }

            // Check that the field number of monotonically increasing
            if (field_number <= previous_field_number) {
                return (false, pos, instance);
            }

            // Check that the wire type is correct
            success = check_key(field_number, wire_type);
            if (!success) {
                return (false, pos, instance);
            }

            // Actually decode the field
            (success, pos) = decode_field(pos, buf, len, field_number, instance);
            if (!success) {
                return (false, pos, instance);
            }

            previous_field_number = field_number;
        }

        // Decoding must have consumed len bytes
        if (pos != initial_pos + len) {
            return (false, pos, instance);
        }

        return (true, pos, instance);
    }

    function check_key(uint64 field_number, ProtobufLib.WireType wire_type) internal pure returns (bool) {
        if (field_number == 1) {
            return wire_type == ProtobufLib.WireType.LengthDelimited;
        }

        return false;
    }

    function decode_field(uint64 initial_pos, bytes memory buf, uint64 len, uint64 field_number, Topic memory instance) internal pure returns (bool, uint64) {
        uint64 pos = initial_pos;

        if (field_number == 1) {
            bool success;
            (success, pos) = decode_1(pos, buf, instance);
            if (!success) {
                return (false, pos);
            }

            return (true, pos);
        }

        return (false, pos);
    }

    // Topic.topic
    function decode_1(uint64 pos, bytes memory buf, Topic memory instance) internal pure returns (bool, uint64) {
        bool success;

        string memory v;
        (success, pos, v) = ProtobufLib.decode_string(pos, buf);
        if (!success) {
            return (false, pos);
        }

        // Default value must be omitted
        if (bytes(v).length == 0) {
            return (false, pos);
        }

        instance.topic = v;

        return (true, pos);
    }

}

